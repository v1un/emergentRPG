{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"];\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n  constructor(_ref) {\n    let {\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\"\n      } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded);\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.createdAt = time.now();\n    this.options = _objectSpread({\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType\n    }, options);\n    this.updateFinishedPromise();\n  }\n  /**\n   * This method uses the createdAt and resolvedAt to calculate the\n   * animation startTime. *Ideally*, we would use the createdAt time as t=0\n   * as the following frame would then be the first frame of the animation in\n   * progress, which would feel snappier.\n   *\n   * However, if there's a delay (main thread work) between the creation of\n   * the animation and the first commited frame, we prefer to use resolvedAt\n   * to avoid a sudden jump into the animation.\n   */\n  calcStartTime() {\n    if (!this.resolvedAt) return this.createdAt;\n    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n  }\n  /**\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\n   * this.resolved will synchronously flush all pending keyframe resolvers.\n   * This is a deoptimisation, but at its worst still batches read/writes.\n   */\n  get resolved() {\n    if (!this._resolved && !this.hasAttemptedResolve) {\n      flushKeyframeResolvers();\n    }\n    return this._resolved;\n  }\n  /**\n   * A method to be called when the keyframes resolver completes. This method\n   * will check if its possible to run the animation and, if not, skip it.\n   * Otherwise, it will call initPlayback on the implementing class.\n   */\n  onKeyframesResolved(keyframes, finalKeyframe) {\n    this.resolvedAt = time.now();\n    this.hasAttemptedResolve = true;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      onComplete,\n      onUpdate,\n      isGenerator\n    } = this.options;\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n    if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n      // Finish immediately\n      if (instantAnimationState.current || !delay) {\n        onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.resolveFinishedPromise();\n        return;\n      }\n      // Finish after a delay\n      else {\n        this.options.duration = 0;\n      }\n    }\n    const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n    if (resolvedAnimation === false) return;\n    this._resolved = _objectSpread({\n      keyframes,\n      finalKeyframe\n    }, resolvedAnimation);\n    this.onPostResolved();\n  }\n  onPostResolved() {}\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n  flatten() {\n    this.options.type = \"keyframes\";\n    this.options.ease = \"linear\";\n  }\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n}\nexport { BaseAnimation };","map":{"version":3,"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","constructor","_ref","autoplay","delay","type","repeat","repeatDelay","repeatType","options","_objectWithoutProperties","_excluded","isStopped","hasAttemptedResolve","createdAt","now","_objectSpread","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise"],"sources":["/app/frontend/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}